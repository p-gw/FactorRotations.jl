var documenterSearchIndex = {"docs":
[{"location":"guides/multivariatestats/#Working-with-MultivariateStats.jl","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"","category":"section"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"FactorRotations.jl provides direct support for models fitted by MultivariateStats.jl. Specifically, you can fit a factor analysis or principal component analysis model and directly rotate the resulting loading matrix. ","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"To user FactorRotations.jl with MultivariateStats.jl we first need to fit a factor analysis or principal component analysis model. In this tutorial we will be using the bfi data provided by the psych R package. It contains 25 self report items concerning personality. ","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"note: Note\nFor performance reasons we just use the first 200 observations of the dataset.","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"warning: Warning\nMissing values are dropped for purposes of this tutorial.  Properly handle missing data in your own analysis!","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"julia> using FactorRotations, MultivariateStats, RDatasets\n\njulia> data = dataset(\"psych\", \"bfi\")[:, 2:26] |> dropmissing!;\n\njulia> data = Matrix(data[1:200, :]);  # use just the first 200 observations\n\njulia> model = fit(FactorAnalysis, data', maxoutdim = 5)\nFactor Analysis(indim = 25, outdim = 5)","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"After fitting the model the loadings could be extracted using MultivariateStats.loadings and then rotated,","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"julia> raw_loadings = MultivariateStats.loadings(model);\n\njulia> rotated_loadings = FactorRotations.loadings(rotate(raw_loadings, Geomin()));\n","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"However, FactorAnalysis.jl provides convenience functions to pass model directly. Analogous to rotating raw loading matrices, there are two ways to rotate a MultivariateStats.jl solution: regular and in-place.  For both we can pass our model to rotate or rotate! respectively.","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"Using rotate,","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"julia> rot = rotate(model, Geomin());\n\njulia> FactorRotations.loadings(rot) == rotated_loadings\ntrue","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"Similarly we can use rotate! to change the loading matrix of model in-place.","category":"page"},{"location":"guides/multivariatestats/","page":"Working with MultivariateStats.jl","title":"Working with MultivariateStats.jl","text":"julia> rotate!(model, Geomin());\n\njulia> MultivariateStats.loadings(model) == rotated_loadings\ntrue","category":"page"},{"location":"guides/implementing_rotation_methods/#Implementing-a-rotation-method","page":"Implementing rotation methods","title":"Implementing a rotation method","text":"","category":"section"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"If you wish to implement your own factor rotation method or extend this package, you can do so in two ways:","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Implementing a rotation method without specifying the gradient\nImplementing a rotation method with gradients","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"In the following guide we will walk through both ways of implementing a rotation method. As an example we will reimplement Quartimax, which minimizes ","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Q = sum_p sum_k lambda_pk^4","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"where p and k are the row and column indices of factor loading matrix Lambda and lambda_pk are the entries of the factor loading matrix. ","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"The first step to a custom implementation is to define a new struct for the rotation method. FactorRotations.jl requires that all rotation methods inherit from RotationMethod. One must also specify whether the new method can be used for orthogonal rotation, oblique rotation, or both.  For orthogonal rotation it is required that T <: RotationMethod{Orthogonal}. Oblique rotations must satisfy T <: RotationMethod{Oblique}. Methods that can be used for both orthogonal and oblique rotation are defined T{RT} <: RotationMethod{RT}.","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Since Quartimax is an orthogonal rotation method, we define it as such.","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> using FactorRotations\n\njulia> struct MyQuartimax <: RotationMethod{Orthogonal} end\n","category":"page"},{"location":"guides/implementing_rotation_methods/#Gradient-free-methods","page":"Implementing rotation methods","title":"Gradient free methods","text":"","category":"section"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"If no gradients are available, the easiest way to define a rotation method is to implement criterion. FactorRotations.jl will then use Automatic Differentiation to derive the gradients for your method.","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> import FactorRotations: criterion\n\njulia> function criterion(method::MyQuartimax, Λ::AbstractMatrix)\n           return -sum(Λ .^ 4)\n       end;\n\njulia> criterion(MyQuartimax(), ones(10, 2))\n-20.0","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"note: Note\nSince the algorithm in this package minimizes the criterion value, we have to make sure to return -sum(...) instead of the original criterion for Quartimax. ","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Once implemented, the required gradients for rotation will be automatically supplied by FactorRotations.jl.","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> criterion_and_gradient(MyQuartimax(), ones(10, 2))\n(-20.0, [-4.0 -4.0; -4.0 -4.0; … ; -4.0 -4.0; -4.0 -4.0])","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> L_rotated = rotate(L, MyQuartimax()) \nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.898755  0.194824\n 0.933943  0.129749\n 0.902131  0.103864\n 0.876508  0.171284\n 0.315572  0.876476\n 0.251123  0.773489\n 0.198007  0.714678\n 0.307857  0.659334","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Checking against the Quartimax implementation shows that the results are approximately equal.","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> L_reference = rotate(L, Quartimax())\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.898755  0.194823\n 0.933943  0.129748\n 0.902132  0.103864\n 0.876508  0.171284\n 0.315572  0.876476\n 0.251124  0.773489\n 0.198008  0.714678\n 0.307858  0.659334","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> isapprox(loadings(L_rotated), loadings(L_reference), atol = 1e-5)\ntrue","category":"page"},{"location":"guides/implementing_rotation_methods/#Methods-with-gradients","page":"Implementing rotation methods","title":"Methods with gradients","text":"","category":"section"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"When gradients are available it can be helpful to implementing them directly. In this case criterion_and_gradient can be directly implemented. This can be beneficial for example if computation can be reused between the calculation of the criterion and its gradient.","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Continuing the example of MyQuartimax:","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> import FactorRotations: criterion_and_gradient\n\njulia> function criterion_and_gradient(method::MyQuartimax, Λ::AbstractMatrix)\n           Q = criterion(method, Λ)\n           ∇Q = -Λ.^3\n           return Q, ∇Q\n       end;","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Evaluating the function will now use the newly defined method, ","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> criterion_and_gradient(MyQuartimax(), ones(10, 2))\n(-20.0, [-1.0 -1.0; -1.0 -1.0; … ; -1.0 -1.0; -1.0 -1.0])","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"Again, this method can be simply used with rotate, now using the custom criterion_and_gradient.","category":"page"},{"location":"guides/implementing_rotation_methods/","page":"Implementing rotation methods","title":"Implementing rotation methods","text":"julia> L_rotated = rotate(L, MyQuartimax())\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.898755  0.194824\n 0.933943  0.129749\n 0.902131  0.103865\n 0.876508  0.171285\n 0.315572  0.876476\n 0.251123  0.773489\n 0.198007  0.714678\n 0.307857  0.659335\n\njulia> isapprox(loadings(L_rotated), loadings(L_reference), atol = 1e-5)\ntrue","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = FactorRotations","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Rotation-criteria","page":"API","title":"Rotation criteria","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Absolmin\nBiquartimax\nComponentLoss\nConcave\nCrawfordFerguson\nInfomax\nKatzRohlf\nLinearRightConstant\nMinimumEntropy\nMinimumEntropyRatio\nOblimax\nOblimin\nPatternSimplicity\nQuartimax\nTandemCriteria\nTandemCriterionI\nTandemCriterionII\nTargetRotation\nVarimax","category":"page"},{"location":"api/#FactorRotations.Absolmin","page":"API","title":"FactorRotations.Absolmin","text":"Absolmin(epsilon = 0)\n\nThe Absolmin component loss factor rotation criterion. It has the loss function\n\nh(lambda) = lambda\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Biquartimax","page":"API","title":"FactorRotations.Biquartimax","text":"Biquartimax()\n\nThe Biquartimax rotation method.\n\nDetails\n\nThe Biquartimax rotation method is a special case of the Oblimin rotation with parameters gamma = 0.5 and orthogonal = true.\n\nExamples\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> L_biquartimax = rotate(L, Biquartimax());\n\njulia> L_oblimin = rotate(L, Oblimin(gamma = 0.5, orthogonal = true));\n\njulia> loadings(L_biquartimax) ≈ loadings(L_oblimin)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.ComponentLoss","page":"API","title":"FactorRotations.ComponentLoss","text":"ComponentLoss(loss::Function; orthogonal = false)\n\nA generic implementation of the component loss factor rotation method. loss defines the loss function that is applied to the components of the loading matrix.\n\nKeyword arguments\n\northogonal: If orthogonal = true an orthogonal rotation is performed, an oblique  rotation otherwise. (default: false)\n\nDetails\n\nThe component loss factor rotation applies a loss function to each element of the factor loading matrix. Then the following criterion is minimized:\n\nQ(Lambda) = sum_i sum_j h(lambda_ij)\n\nExamples\n\nQuartimax as a component loss\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> quartimax_loss = ComponentLoss(x -> x^4, orthogonal = true);\n\njulia> L_component_loss = rotate(L, quartimax_loss)\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.898755  0.194824\n 0.933943  0.129749\n 0.902131  0.103864\n 0.876508  0.171284\n 0.315572  0.876476\n 0.251123  0.773489\n 0.198007  0.714678\n 0.307857  0.659334\n\njulia> L_quartimax = rotate(L, Quartimax())\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.898755  0.194823\n 0.933943  0.129748\n 0.902132  0.103864\n 0.876508  0.171284\n 0.315572  0.876476\n 0.251124  0.773489\n 0.198008  0.714678\n 0.307858  0.659334\n\njulia> isapprox(loadings(L_component_loss), loadings(L_quartimax), atol = 1e-5)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Concave","page":"API","title":"FactorRotations.Concave","text":"Concave(bandwidth = 1)\n\nThe simple concave component loss factor rotation criterion. It has the loss function\n\nh(lambda) = 1 - exp(-fraclambdab)\n\nwhere b is the bandwidth parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.CrawfordFerguson","page":"API","title":"FactorRotations.CrawfordFerguson","text":"CrawfordFerguson(; kappa, orthogonal = false)\n\nThe family of Crawford-Ferguson rotation methods.\n\nKeyword arguments\n\nkappa: The parameter determining the rotation criterion (see Details).\northogonal: orthogonal: If orthogonal = true an orthogonal rotation is performed, an               oblique rotation otherwise. (default: false)\n\nDetails\n\nThe Crawford-Ferguson family allows both orthogonal and oblique rotation of the p-byk-factor loading matrix. If orthogonal rotation is performed, Crawford-Ferguson is equivalent to Oblimin rotation given the following values for kappa:\n\nkappa = 0 → Quartimax\nkappa = 1/p → Varimax\nkappa = k/2p → Equamax\nkappa = (k - 1)/(p + k - 2) → Parsimax\nkappa = 1 → Factor parsimony\n\nExamples\n\njulia> CrawfordFerguson(kappa = 0, orthogonal = true)\nCrawfordFerguson{Orthogonal, Int64}(0)\n\njulia> CrawfordFerguson(kappa = 1/2, orthogonal = false)\nCrawfordFerguson{Oblique, Float64}(0.5)\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Infomax","page":"API","title":"FactorRotations.Infomax","text":"Infomax(; orthogonal = false)\n\nThe Infomax rotation method.\n\nKeyword arguments\n\northogonal: If orthogonal = true an orthogonal rotation is performed, an oblique  rotation otherwise. (default: false)\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.KatzRohlf","page":"API","title":"FactorRotations.KatzRohlf","text":"KatzRohlf(bandwidth)\n\nA component loss criterion with loss function\n\nh(lambda) = 1 - exp(-(fraclambdab)^2)\n\nwhere b is the bandwidth parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.LinearRightConstant","page":"API","title":"FactorRotations.LinearRightConstant","text":"LinearRightConstant(bandwidth)\n\nThe linear right constant component loss factor rotation criterion. It has the loss function\n\nh(lambda) = begincases\n    (fraclambdab)^2textif  lambda leq b \n    1 textif  lambda  b\nendcases\n\nwhere b is the bandwidth parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.MinimumEntropy","page":"API","title":"FactorRotations.MinimumEntropy","text":"MinimumEntropy()\n\nThe Minimum Entropy rotation method.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.MinimumEntropyRatio","page":"API","title":"FactorRotations.MinimumEntropyRatio","text":"MinimumEntropyRatio()\n\nThe Minimum Entropy Ratio rotation method.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Oblimax","page":"API","title":"FactorRotations.Oblimax","text":"Oblimax(; orthogonal = false)\n\nThe Oblimax rotation method.\n\nKeyword arguments\n\northogonal: If orthogonal = true an orthogonal rotation is performed, an oblique  rotation otherwise. (default: false)\n\nDetails\n\nThe Oblimax rotation method is equivalent to Quartimax for orthogonal rotation.\n\nExamples\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> L_oblimax = rotate(L, Oblimax(orthogonal = true));\n\njulia> L_quartimax = rotate(L, Quartimax());\n\njulia> isapprox(loadings(L_oblimax), loadings(L_quartimax), atol = 1e-6)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Oblimin","page":"API","title":"FactorRotations.Oblimin","text":"Oblimin(; gamma, orthogonal = false)\n\nThe family of Oblimin rotation methods.\n\nKeyword arguments\n\ngamma: The shape parameter determining the rotation criterion (see Details).\northogonal: If orthogonal = true an orthogonal rotation is performed, an oblique  rotation otherwise. (default: false)\n\nDetails\n\nThe Oblimin rotation family allow orthogonal as well as oblique rotation of the factor loading matrix. If orthogonal rotation is performed, Oblimin is equivalent to the following rotation methods given a value for gamma:\n\ngamma = 0 → Quartimax\ngamma = 0.5 → Biquartimax\ngamma = 1 → Varimax\ngamma = p/2 → Equamax\n\nFor oblique rotation Oblimin is equivalent to the following rotation methods:\n\ngamma = 0 → Quartimin\ngamma = 0.5 → Biquartimin\n\nExamples\n\njulia> Oblimin(gamma = 0.5)\nOblimin{Oblique, Float64}(0.5)\n\njulia> Oblimin(gamma = 1, orthogonal = true)\nOblimin{Orthogonal, Int64}(1)\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.PatternSimplicity","page":"API","title":"FactorRotations.PatternSimplicity","text":"PatternSimplicity(; orthogonal = false)\n\nThe Pattern Simplicity factor rotation criterion.\n\nKeyword arguments\n\northogonal: If orthogonal = true an orthogonal rotation is performed, an oblique  rotation otherwise. (default: false)\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Quartimax","page":"API","title":"FactorRotations.Quartimax","text":"Quartimax()\n\nThe Quartimax rotation criterion.\n\nDetails\n\nThe Quartimax criterion is a special case of the Oblimin rotation criterion with parameter gamma = 0.\n\nExamples\n\nSetting up the criterion\n\njulia> Quartimax()\nQuartimax()\n\nTesting equivalence of Quartimax and Oblimin\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> L_quartimax = rotate(L, Quartimax());\n\njulia> L_oblimin = rotate(L, Oblimin(gamma = 0, orthogonal = true));\n\njulia> loadings(L_quartimax) ≈ loadings(L_oblimin)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.TandemCriteria","page":"API","title":"FactorRotations.TandemCriteria","text":"TandemCriteria(; keep)\n\nThe tandem criteria rotation method.\n\nKeyword arguments\n\nkeep: The number of factors to keep for the second tandem criterion.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.TandemCriterionI","page":"API","title":"FactorRotations.TandemCriterionI","text":"TandemCriterionI()\n\nThe first criterion of the tandem criteria factor rotation method.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.TandemCriterionII","page":"API","title":"FactorRotations.TandemCriterionII","text":"TandemCriterionI()\n\nThe second criterion of the tandem criteria factor rotation method.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.TargetRotation","page":"API","title":"FactorRotations.TargetRotation","text":"TargetRotation(target::AbstractMatrix; orthogonal = false)\n\nThe (partial) target rotation criterion.\n\nKeyword arguments\n\northogonal: If orthogonal = true an orthogonal rotation is performed, an oblique  rotation otherwise. (default: false)\n\nDetails\n\nTarget rotation rotates a factor loading matrix towards the target matrix, target. For a fully specified target matrix (e.g. all entries in the matrix are numbers), full target rotation is performed.\n\nPartially specified target rotation can be achieved setting the unspecified entries in the target matrix to missing.\n\nExamples\n\nFull target rotation\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> target = [1 0; 1 0; 1 0; 1 0; 0 1; 0 1; 0 1; 0 1];\n\njulia> rotate(L, TargetRotation(target, orthogonal = true))\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.882633  0.258215\n 0.922358  0.195806\n 0.892467  0.167726\n 0.862116  0.233154\n 0.252473  0.89669\n 0.195508  0.789382\n 0.146707  0.726945\n 0.260213  0.679549\n\nPartially specified target rotation\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> target = [1 0; missing missing; 1 0; 1 0; 0 1; 0 1; 0 1; 0 1];\n\njulia> rotate(L, TargetRotation(target, orthogonal = true))\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.873299  0.288209\n 0.915133  0.227193\n 0.886218  0.198109\n 0.85365   0.262462\n 0.221701  0.90479\n 0.168434  0.795599\n 0.121793  0.731532\n 0.236852  0.68804\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Varimax","page":"API","title":"FactorRotations.Varimax","text":"Varimax()\n\nThe Varimax rotation criterion.\n\nDetails\n\nThe Varimax criterion is a special case of the Oblimin rotation criterion with parameter gamma = 1.\n\nExamples\n\nSetting up the criterion\n\njulia> Varimax()\nVarimax()\n\nTesting equivalence of Varimax and Oblimin\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> L_varimax = rotate(L, Varimax());\n\njulia> L_oblimin = rotate(L, Oblimin(gamma = 1, orthogonal = true));\n\njulia> loadings(L_varimax) ≈ loadings(L_oblimin)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#User-Interface","page":"API","title":"User Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"setverbosity!\nrotate\nrotate!\nisorthogonal\nisoblique\nloadings\nrotation\nfactor_correlation","category":"page"},{"location":"api/#FactorRotations.setverbosity!","page":"API","title":"FactorRotations.setverbosity!","text":"setverbosity!(::Bool)\n\nSets the global verbosity level of the package. If set to false (the default), package functions will not log @info statements. If set to true, package functions will provide @info statements.\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.rotate","page":"API","title":"FactorRotations.rotate","text":"rotate(Λ, method::RotationMethod; kwargs...)\n\nPerform a rotation of the factor loading matrix Λ using a rotation method.\n\nKeyword arguments\n\natol: Sets the absolute tolerance for convergence of the algorithm (default: 1e-6).\nalpha: Sets the inital value for alpha (default: 1).\nmaxiter1: Controls the number of maximum iterations in the outer loop of the algorithm             (default: 1000).\nmaxiter2: Controls the number of maximum iterations in the inner loop of the algorithm             (default: 10).\ninit: A k-by-k matrix of starting values for the algorithm.         If init = nothing (the default), the identity matrix will be used as starting         values.\nverbose: Print logging statements (default: false)\n\nExamples\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> rotate(L, Varimax())\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.886061  0.246196\n 0.924934  0.183253\n 0.894664  0.155581\n 0.865205  0.221416\n 0.264636  0.893176\n 0.206218  0.786653\n 0.156572  0.724884\n 0.269424  0.67595\n\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.rotate!","page":"API","title":"LinearAlgebra.rotate!","text":"rotate!(Λ, method::RotationMethod; kwargs...)\n\nPerform a rotation of the factor loading matrix Λ and overwrite Λ with the rotated loading matrix.\n\nFor a list of available keyword arguments see rotate.\n\nExamples\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ];\n\njulia> rotate!(L, Quartimax())\n8×2 Matrix{Float64}:\n 0.898755  0.194823\n 0.933943  0.129748\n 0.902132  0.103864\n 0.876508  0.171284\n 0.315572  0.876476\n 0.251124  0.773489\n 0.198008  0.714678\n 0.307858  0.659334\n\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.isorthogonal","page":"API","title":"FactorRotations.isorthogonal","text":"isorthogonal(::RotationMethod)\n\nChecks if the supplied rotation method is orthogonal.\n\nExamples\n\njulia> isorthogonal(Varimax())\ntrue\n\njulia> isorthogonal(Oblimax(orthogonal = false))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.isoblique","page":"API","title":"FactorRotations.isoblique","text":"isoblique(::RotationMethod)\n\nChecks if the supplied rotation method is oblique.\n\nExamples\n\njulia> isoblique(Varimax())\nfalse\n\njulia> isoblique(Oblimax(orthogonal = false))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.loadings","page":"API","title":"FactorRotations.loadings","text":"loadings(r::FactorRotation)\n\nReturn the rotated factor loading matrix from r.\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.rotation","page":"API","title":"FactorRotations.rotation","text":"rotation(r::FactorRotation)\n\nReturn the factor rotation matrix from r.\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.factor_correlation","page":"API","title":"FactorRotations.factor_correlation","text":"factor_correlation(r::FactorRotation)\n\nReturn the factor correlation matrix from r.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FactorRotation\nRotationMethod\nOrthogonal\nOblique\ncriterion\ncriterion_and_gradient","category":"page"},{"location":"api/#FactorRotations.FactorRotation","page":"API","title":"FactorRotations.FactorRotation","text":"FactorRotation{T <: Real}\n\nA type holding results of a factor rotation.\n\nFields\n\nL: The rotated factor loading matrix\nT: The factor rotation matrix\nphi: The factor correlation matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.RotationMethod","page":"API","title":"FactorRotations.RotationMethod","text":"RotationMethod{T<:RotationType}\n\nAn abstract type representing a factor rotation method.\n\nEach implementation of M <: RotationMethod must implement at least one of the following methods:\n\ncriterion\ncriterion_and_gradient\n\nIf criterion is implemented, gradients are calculated by automatic differentiation.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Orthogonal","page":"API","title":"FactorRotations.Orthogonal","text":"Orthogonal\n\nA type representing an orthogonal rotation type.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.Oblique","page":"API","title":"FactorRotations.Oblique","text":"Oblique\n\nA type representing an oblique rotation type.\n\n\n\n\n\n","category":"type"},{"location":"api/#FactorRotations.criterion","page":"API","title":"FactorRotations.criterion","text":"criterion(method::RotationMethod, Λ::Abstractmatrix{<:Real})\n\nCalculate the criterion of a given method with respect to the factor loading matrix Λ.\n\n\n\n\n\n","category":"function"},{"location":"api/#FactorRotations.criterion_and_gradient","page":"API","title":"FactorRotations.criterion_and_gradient","text":"criterion_and_gradient(method::RotationMethod, Λ::AbstractMatrix{<:Real})\n\nCalculate the criterion and gradient of a given method with respect to the factor loading matrix Λ.\n\nReturns a Tuple with the criterion value as the first element and gradient as the second element.\n\n\n\n\n\n","category":"function"},{"location":"guides/basic_usage/#Rotate-an-existing-loading-matrix","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"","category":"section"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"This guide considers the basic use case of FactorRotations.jl: Given an existing factor loading matrix L, calculate the rotation of the loading matrix according to some rotation criterion. In this example we will first consider the simple case of orthogonal Varimax rotation. At a later stage we will see how to easily switch the factor rotation criterion to arrive at a different rotation.","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"First, we assume a factor loading matrix L.  In this example we will use the loading matrix given by Bernaard & Jennrich (2005),","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"julia> using FactorRotations\n\njulia> L = [\n           0.830 -0.396\n           0.818 -0.469\n           0.777 -0.470\n           0.798 -0.401\n           0.786  0.500\n           0.672  0.458\n           0.594  0.444\n           0.647  0.333\n       ]\n8×2 Matrix{Float64}:\n 0.83   -0.396\n 0.818  -0.469\n 0.777  -0.47\n 0.798  -0.401\n 0.786   0.5\n 0.672   0.458\n 0.594   0.444\n 0.647   0.333","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"Rotating the loading matrix consists of a single call to rotate. This function takes the unrotated loading matrix as the first argument, and an instance of a factor rotation method as a second argument.","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"For clarity we first set up our Varimax rotation method,","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"julia> criterion = Varimax()\nVarimax()","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"Finally we perform the rotation using rotate,","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"julia> L_rotated = rotate(L, criterion)\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.886061  0.246196\n 0.924934  0.183253\n 0.894664  0.155581\n 0.865205  0.221416\n 0.264636  0.893176\n 0.206218  0.786653\n 0.156572  0.724884\n 0.269424  0.67595","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"Different rotation can be achieved by simply changing criterion or passing it directly to rotate.","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"julia> L_rotated = rotate(L, MinimumEntropy())\nFactorRotation{Float64} with loading matrix:\n8×2 Matrix{Float64}:\n 0.90711   0.151221\n 0.939117  0.084524\n 0.906093  0.0602051\n 0.883753  0.128783\n 0.357504  0.860225\n 0.28816   0.760468\n 0.232268  0.704289\n 0.339319  0.643709 ","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"The resulting FactorRotation object contains the rotated loading matrix, the rotation matrix, and the factor correlation matrix. To access the fields you can use loadings, rotation, and factor_correlation respectively.","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"julia> loadings(L_rotated)\n8×2 Matrix{Float64}:\n 0.90711   0.151221\n 0.939117  0.084524\n 0.906093  0.0602051\n 0.883753  0.128783\n 0.357504  0.860225\n 0.28816   0.760468\n 0.232268  0.704289\n 0.339319  0.643709 \n\njulia> rotation(L_rotated)\n2×2 Matrix{Float64}:\n  0.819445  0.573158\n -0.573158  0.819445\n\njulia> factor_correlation(L_rotated)\n2×2 Matrix{Float64}:\n  1.0          -1.66533e-16\n -1.66533e-16   1.0\n","category":"page"},{"location":"guides/basic_usage/#In-place-rotation","page":"Rotate an existing loading matrix","title":"In-place rotation","text":"","category":"section"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"In some cases it can be useful to modify L directly.  For this use case the package provides an in-place rotation, rotate! with the same function signature as before.","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"warning: Warning\nContrary to rotate, the in-place rotate! returns the loading matrix instead of a FactorRotation object.","category":"page"},{"location":"guides/basic_usage/","page":"Rotate an existing loading matrix","title":"Rotate an existing loading matrix","text":"julia> rotate!(L, MinimumEntropy())\n8×2 Matrix{Float64}:\n 0.90711   0.151221\n 0.939117  0.084524\n 0.906093  0.0602051\n 0.883753  0.128783\n 0.357504  0.860225\n 0.28816   0.760468\n 0.232268  0.704289\n 0.339319  0.643709 \n\njulia> L == loadings(L_rotated)\ntrue","category":"page"},{"location":"rotation_methods/#Rotation-Criteria","page":"Rotation Methods","title":"Rotation Criteria","text":"","category":"section"},{"location":"rotation_methods/","page":"Rotation Methods","title":"Rotation Methods","text":"FactorRotations.jl implements both orthogonal and oblique rotation criteria. The following tables list the available methods and their respective references.","category":"page"},{"location":"rotation_methods/#Orthogonal-rotation-criteria","page":"Rotation Methods","title":"Orthogonal rotation criteria","text":"","category":"section"},{"location":"rotation_methods/","page":"Rotation Methods","title":"Rotation Methods","text":"criterium reference note\nBiquartimax  equivalent to Oblimin(gamma = 0.5, orthogonal = true)\nCrawfordFerguson Crawford and Ferguson (1970) \nInfomax Browne (2001) based on the unpublished manuscript McKeon (1968)\nKatzRohlf  \nLinearRightConstant Jennrich (2004) \nMinimumEntropyRatio McCammon (1966) \nMinimumEntropy Jennrich (2004) \nOblimax  \nOblimin  equivalent to Oblimin for orthogonal rotation\nQuartimax Neuhaus and Wrigley (1954) equivalent to Oblimin(gamma = 0, orthogonal = true)\nTandemCriteria Comrey (1967) \nTandemCriterionII Comrey (1967) \nTandemCriterionI Comrey (1967) \nTargetRotation  \nVarimax Kaiser (1958) equivalent to Oblimin(gamma = 1, orthogonal = true)","category":"page"},{"location":"rotation_methods/#Oblique-rotation-criteria","page":"Rotation Methods","title":"Oblique rotation criteria","text":"","category":"section"},{"location":"rotation_methods/","page":"Rotation Methods","title":"Rotation Methods","text":"criterium reference note\nAbsolmin Jennrich (2006) \nComponentLoss Jennrich (2004), Jennrich (2006) both orthogonal and oblique\nConcave Jennrich (2006) \nPatternSimplicity Bentler (1977) both orthogonal and oblique","category":"page"},{"location":"rotation_methods/#References","page":"Rotation Methods","title":"References","text":"","category":"section"},{"location":"rotation_methods/","page":"Rotation Methods","title":"Rotation Methods","text":"Bentler, P. (1977). Factor simplicity index and transformations. Psychometrika 42, 277–295.\n\n\n\nBrowne, M. W. (2001). An overview of analytic rotation in exploratory factor analysis. Multivariate behavioral research 36, 111–150.\n\n\n\nComrey, A. L. (1967). Tandem criteria for analytic rotation in factor analysis. Psychometrika 32, 143–154.\n\n\n\nCrawford, C. B. and Ferguson, G. A. (1970). A general rotation criterion and its use in orthogonal rotation. Psychometrika 35, 321–332.\n\n\n\nJennrich, R. I. (2004). Rotation to simple loadings using component loss functions: The orthogonal case. Psychometrika 69, 257–273.\n\n\n\nJennrich, R. I. (2006). Rotation to simple loadings using component loss functions: The oblique case. Psychometrika 71, 173–191.\n\n\n\nKaiser, H. F. (1958). The varimax criterion for analytic rotation in factor analysis. Psychometrika 23, 187–200.\n\n\n\nMcCammon, R. B. (1966). Principal component analysis and its application in large-scale correlation studies. The Journal of Geology 74, 721–733.\n\n\n\nNeuhaus, J. O. and Wrigley, C. (1954). The quartimax method: An analytic approach to orthogonal simple structure. British Journal of Statistical Psychology 7, 81–91.\n\n\n\n","category":"page"},{"location":"#FactorRotations.jl","page":"Home","title":"FactorRotations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"FactorRotations.jl implements factor rotations by the gradient projections algorithms described in Bernaards & Jennrich (2005).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install FactorRotations.jl you can use the Julia package manager,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add FactorRotations","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FactorRotations.jl provides methods to rotate factor loading matrices, e.g. from  exploratory factor analysis or principle component analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assume you aquired a factor loading matrix L then you can rotate the matrix by calling the rotate function. The rotate function takes the factor loading matrix as the first argument and an instance of a rotation method as the second argument.","category":"page"},{"location":"","page":"Home","title":"Home","text":"L = [\n    0.830 -0.396\n    0.818 -0.469\n    0.777 -0.470\n    0.798 -0.401\n    0.786  0.500\n    0.672  0.458\n    0.594  0.444\n    0.647  0.333\n]\n\nrotate(L, Varimax())","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a complete list of available methods see the Rotation Methods section of the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a fully worked example see the Guides section of the documentation.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bernaards, C. A., & Jennrich, R. I. (2005). Gradient projection algorithms and software for arbitrary rotation criteria in factor analysis. Educational and psychological measurement, 65(5), 676-696.","category":"page"},{"location":"guides/#Guides","page":"Guides","title":"Guides","text":"","category":"section"},{"location":"guides/","page":"Guides","title":"Guides","text":"Rotate an existing loading matrix\nImplementing a rotation method","category":"page"}]
}
